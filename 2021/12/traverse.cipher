// Replace each Small Cave with a one-way path
match (c:SmallCave)
create (en:CaveEntry { name: c.name }),
       (ex:CaveExit { name: c.name }),
       (c)-[:replace]->(en),
       (en)-[:oneway]->(ex);

// Connect entries and exits to related nodes, one direction
match (x1)<-[:oneway]-(e1)<-[:replace]-(c1:SmallCave)
      -[:path]->
      (c2:SmallCave)-[:replace]->(e2)-[:oneway]->(x2)
create (x1)-[:path]->(e2),
       (x2)-[:path]->(e1);

match (c1:BigCave)-[:path]-
      (c2:SmallCave)-[:replace]->(e2)-[:oneway]->(x2)
create (c1)-[:path]->(e2),
       (x2)-[:path]->(c1);

match (s:Start)-[:path]-(c2:SmallCave)-[:replace]->(e2)
create (s)-[:path]->(e2);

match (s:End)-[:path]-(c2:SmallCave)-[:replace]->(e2)-[:oneway]->(x2)
create (s)<-[:path]-(x2);

// Delete original Small Caves
match (n:SmallCave) detach delete n;

// Part 1: count of possible paths
match p = (a:Start)-[*]->(b:End) return count(p);

// (Debug)
match p = (a:Start)-[r*]->(b:End) return [n in nodes(p) | n.name];
match p = (a:Start)-[r*]->(b:End) return [rr in r | type(rr)];

// Part 2: add a 2nd path through each Small Cave

// This seems like it would work, but takes wayyy too long. The nested * loop must be the issue.
match (e)-[:oneway]->(x) create (e)-[:second]->(x);
match p = (a:Start)-[r1:path|oneway*]->(n)-[r2:second]->(m)-[r3:path|oneway*]->(b:End) return count(p);
match p = (a:Start)-[r1:path|oneway*]->(n)-[r2:second]->(m)-[r3:path|oneway*]->(b:End) return p;

// REVERT...
match (e)-[r:second]->(x) delete r;

// One at a time:
match (e { name: 'b'})-[:oneway]->(x) create (e)-[:second]->(x);


// any node can repeat
match p = (a:Start)-[*]-(b:End) return nodes(p);
